*--------------------------------------------------------------------*
* !!!!!! DO NOT CHANGE MANUALLY !!!!!!
*
* automatically generated by report GFW_DCWIZARD
* version         : 5.10
* timestamp       : 20001204 / 144108
* by              : GUTENKUNST
* with following parameters
* DDIC            : GFWDCPREST
* key attribute   : OBJID
* filter attribute: FILTER
* class           : LCL_DC_PREST
* X local_class
* include         : GFW_DC_PRES_T
*
* !!!!!! DO NOT CHANGE MANUALLY !!!!!!
*----------------------------------------------------------------------*
* INCLUDE GFW_DC_PRES_T *
*----------------------------------------------------------------------*
* TEMPLATE USED BY DC-WIZARD:
* SIMPLE DATA CONTAINER FOR PRESENTATION GRAPHICS IS TEMPLATE =>
*
* DATA CONTAINER (DC) USING DDIC STRUCT GFWDCPREST

class cl_gfw definition load. "//CONSTANTS FOR RETURNCODES

*---------------------------------------------------------------------*
*       CLASS LCL_DC_PREST
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
class lcl_dc_prest
                  definition inheriting from cl_gfw_dc.
  public section.

    methods: constructor,
*            SET ONE DATA OBJECT/ROW
*            KEY_VALUE INITIAL      => APPEND NEW OBJECT
*            KEY_VALUE =  OBJ-<KEY> => UPDATE OBJECT
*            KEY_VALUE <> OBJ-<KEY> => INSERT OBJECT BEFORE OBJECT_O
*                                      WITH KEY_VALUE = OBJECT_O-<KEY>
             set_obj_values importing id type i
                                      key_value type
gfwdcprest-objid
                                                optional
                                      obj type
gfwdcprest
                            exporting retval type symsgno,
*            SET WHOLE DATA TABLE
*            (RESULTS IN A FULL READ OF GRAPHICS PROXIES,
*             ALL MODES ARE SET TO "INITIAL")
*            IMPORTANT! OBJTAB IS A TABLE OF THE DC'S DATA DDIC TYPE:
*                       GFWDCPREST
             set_obj_tab    importing objtab type any "STANDARD TABLE OF
                                                            "GFWDCPREST
                            exporting retval type symsgno.

    methods:
*            REDEFINED INTERFACE METHODS
             if_dc_access~get_changes     redefinition,
             if_dc_access~set_value       redefinition,
             if_dc_access~get_value       redefinition,
             if_dc_access~del_object      redefinition,
             if_dc_access~clear           redefinition,
             if_dc_access~get_predecessor redefinition,
             if_dc_access~get_successor   redefinition
             .

  protected section.

    methods:
             reset_modes              redefinition,
             get_attrib_mask          redefinition,
             reset_data_changed_flags redefinition
            .

**** WARNING: YOU MAY USE A SUBCLASS OF THIS CLASS TO IMPLEMENT
*             BETTER PERFORMANCE, ADDITIONAL FUNCTIONALITY ETC.
*             (THEREFORE ALL ATTRIBUTES OF THIS CLASS ARE
*              PROTECTED INSTEAD OF PRIVATE)
*             BUT TAKE CARE FOR EXISTING FUNCTIONALITY!

    constants:
*         COUNT OF ATTRIBUTES IN STRUCT
          attrib_count type i value 11 ,
*         NAMES OF SOME IMPORTANT ATTRIBUTES:
          key_attribute type rollname value 'OBJID',
          filter_attribute type rollname value 'FILTER'.

    types:
          ty_mode(11) type x,
*         TABLE WITH STRUCT INFO TO CONVERT ATTRIB NAME INTO COLUMN IDX
*         (TO FIND CHANGE MODE FOR THE ATTRIBUTE'S VALUE)
          begin of ty_offset,
            attribute type rollname,
            offset type i,           "// COLUMN NUMBER (STARTING AT 0!)
          end of ty_offset,
          begin of ty_changed_filter,
            objkey type
gfwdcprest-objid
                   ,
            old_filter type i,
            new_filter type i,
          end of ty_changed_filter.

    data:
*         TABLE TO GET MODE FOR AN ATTRIBUTE'S VALUE (CONSTANT)
          mode_offset        type sorted table of ty_offset
                                  with unique key attribute,
          key_mode_offset    type i,
*         INITIAL MODES (CONSTANT)
          modes_initial      type ty_mode,
*         INSERTED MODES (CONSTANT)
          modes_inserted_app type ty_mode,
          modes_inserted_gp  type ty_mode,
*         DELETED MODES (CONSTANT)
          modes_deleted_app  type ty_mode,
          modes_deleted_gp   type ty_mode,
*         TABLE WITH CURRENT DATA
          data               type standard table of
gfwdcprest
                             with key
          objid,
*         TABLE OF DELETED DATA
          del_data           type standard table of
gfwdcprest
                             with key
          objid,
*         CHANGE MODES FOR DATA
          modes              type standard table of ty_mode,
*         CHANGE MODES FOR DELETED DATA (ONLY MODES OF KEY ATTRIBUTE)
          modes_key_deleted  type standard table of x
                                  with key table_line,

*         FILTER CHANGES
          changed_filter     type sorted table of ty_changed_filter
                                  with unique key objkey,
          filter_mode_offset type i,

*         PERFORMANCE OPTIMIZATION FOR METHOD GET_VALUE
          begin of last_get_value,
            id                     type i,
            data                   type
gfwdcprest,
            modes                  type ty_mode,
            key_attribute          type rollname,
            key_value              type char128,
            value_counter          type i,
            retval                 type symsgno,
            start_idx              type sy-tabix,
*           RECORD IS INVALID IF DATA CHANGED(S. SET_DATA_CHANGED_FLAGS)
            data_changed_after_get type gfw_boolean value gfw_false,
          end of last_get_value,

*         PERFORMANCE OPTIMIZATION FOR METHOD GET_CHANGES
          begin of last_get_changes,
            id                     type i,
            data                   type
gfwdcprest,
            modes                  type ty_mode,
            mode_key_deleted       type x,
            value_counter          type i,
            retval                 type symsgno,
            start_idx_del_data     type sy-tabix,
            start_idx_modes        type sy-tabix,
*           RECORD IS INVALID IF DATA CHANGED(S. SET_DATA_CHANGED_FLAGS)
            data_changed_after_get type gfw_boolean value gfw_false,
          end of last_get_changes.

*         EXTRACT FROM TEMPLATE IN A SEPARATED INCLUDE:
    methods: fill_table_mode_index.

endclass. "//LCL_DC_PREST DEFINITION

*---------------------------------------------------------------------*
*       CLASS LCL_DC_PREST IMPLEMENTATION
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
class lcl_dc_prest implementation.

******
* **** CONSTRUCTOR
******
  method constructor.
    data: offset        type i,
          single_offset type ty_offset.

    call method super->constructor.

    clear data.
* SET MY VERSION
  created_release = 5 .
  created_patch = 10 .
  created_date = '20001204'.
  created_time = '144108'.
    created_dcname = 'LCL_DC_PREST'.
* ABORT IF VERSION CHECK FAILS
    call method check_version.

* FILL (PSEUDO CONST) TABLE MODE_INDEX
    call method fill_table_mode_index.

* FILL (PSEUDO CONST) ATTRIBUTE KEY_MODE_OFFSET
    read table mode_offset into single_offset
                   with table key attribute = key_attribute
                   transporting offset.
    if sy-subrc = 0 or sy-subrc = 2.
      key_mode_offset = single_offset-offset.
    else.
      gfw_write cl_gfw=>e_dc_unknown_attrib
  'LCL_DC_PREST->CONSTR./KEY'                                "#EC NOTEXT
      'W'.
    endif.

* FILL (PSEUDO CONST) ATTRIBUTE FILTER_MODE_OFFSET
    if not filter_attribute is initial.
      read table mode_offset into single_offset
                   with table key attribute = filter_attribute
                   transporting offset.
      if sy-subrc = 0 or sy-subrc = 2.
        filter_mode_offset = single_offset-offset.
      else.
        gfw_write cl_gfw=>e_dc_unknown_attrib
  'LCL_DC_PREST->CONSTR./FILTER'                             "#EC NOTEXT
        'W'.
      endif.
    endif.

* FILL MODES_INITIAL+MODES_INSERTED+MODES_DELETED
* TO GET BETTER PERFORMANCE IN METHODS
* DISTRIBUTE CHANGES AND GET_CHANGES
    do attrib_count times.
      offset = sy-index - 1.
      modes_initial+offset(1)     = if_dc_access=>co_mode_init.
      modes_inserted_app+offset(1)
                                = if_dc_access=>co_mode_inserted_by_app.
     modes_inserted_gp+offset(1) = if_dc_access=>co_mode_inserted_by_gp.
     modes_deleted_app+offset(1) = if_dc_access=>co_mode_deleted_by_app.
      modes_deleted_gp+offset(1)  = if_dc_access=>co_mode_deleted_by_gp.
    enddo.
  endmethod. "//CONSTRUCTOR

******
* **** SET_OBJ_VALUES
******
  method set_obj_values.
    field-symbols: <lcl_dc_prest_attrib>     type any,
                   <lcl_dc_prest_attrib_old> type any,
                   <lcl_dc_prest_key>        type any.

    data: new_mode          type i,              "//KIND OF CHANGE
          ins_mode          type i,              "//KIND OF INSERT
          key_idx           type i,              "//TABIX OF KEY OBJECT
          gp_data           type ty_dc_gp_data, "//CHECK AUTHORISATION
          single_data       type
  gfwdcprest,
        single_offset     type ty_offset, "// OFFSET OF ATTR. (FOR MODE)
         objmodes          type ty_mode,     "// ALL MODES OF CURR. OBJ.
          attrib_type       type ty_ddic_type,"// HANDLE IF_GFW_STATUS
          status_ref        type ref to if_gfw_status,
          obj_ref           type ref to object,
          obj_copy          type
  gfwdcprest,
          changed_filter_wa type ty_changed_filter.

    retval = cl_gfw=>ok.
* GET NEW MODE
    if id = master_id.
      if graphic_proxy_count > 0.
        new_mode = if_dc_access=>co_mode_updated_by_app.
        ins_mode = if_dc_access=>co_mode_inserted_by_app.
      else.
        new_mode = if_dc_access=>co_mode_init.
        ins_mode = if_dc_access=>co_mode_init.
      endif.
    elseif not gp_cause_of_changes is initial and
           gp_cause_of_changes <> id.
      retval = cl_gfw=>e_dc_two_gp_change.
      gfw_write retval
      'LCL_DC_PREST->SET_OBJ_VALUES'                         "#EC NOTEXT
      'W'.
      exit.
    else.
*   UNUSUAL IN THIS CASE BECAUSE IT'S NOT AN INTERFACE METHOD; SO GP
*   SHOULD NOT KNOW ABOUT THIS METHOD; ALLOW METHODCALL ANYWAY
*   CHECK IF GP IS SUBSCRIBED
      read table graphic_proxy_list into gp_data
                           with table key id = id
                           transporting list_of_filter.
      if sy-subrc <> 0 and sy-subrc <> 2.
        retval = cl_gfw=>e_dc_authorisation.
        gfw_write retval
         'LCL_DC_PREST->SET_OBJ_VALUES' 'W'.                 "#EC NOTEXT
        exit.
      endif.
      gp_cause_of_changes = id.
      new_mode = if_dc_access=>co_mode_updated_by_gp.
      ins_mode = if_dc_access=>co_mode_inserted_by_gp.
    endif.

    obj_copy = obj.

    clear key_idx. clear single_data.
* LOOK FOR OBJECT WITH GIVEN KEY (KEY OBJECT)
    if not key_value is initial.
      read table data with table key
      objid
                      = key_value
                      into single_data.
      if sy-subrc = 0 or sy-subrc = 2.
        key_idx = sy-tabix.
      endif.
    endif. "NOT KEY_VALUE IS INITIAL

    if key_idx is initial.
*   TO DO: APPEND NEW OBJECT
*   CHECK KEY
      if obj-objid
                   is initial.
*     KEY MISSING
        retval = cl_gfw=>e_dc_no_keyval.
        gfw_write retval
         'LCL_DC_PREST->SET_OBJ_VALUES' 'W'.                 "#EC NOTEXT
        exit. "//CANCEL, RETURN WITH ERROR
      else.
*     CHECK DOUBLE KEY
        read table data with table key
        objid =
   obj-objid
                        transporting no fields.
        if sy-subrc = 0 or sy-subrc = 2.
*       KEY ALREADY EXISTS
          retval = cl_gfw=>e_dc_dbl_key.
          gfw_write retval
           'LCL_DC_PREST->SET_OBJ_VALUES' 'W'.               "#EC NOTEXT
          exit. "//CANCEL, RETURN WITH ERROR
        endif.
      endif.
*   KEY OK, APPEND OBJECT
*   CHECK STATUS REFERENCES, COPY STATUS OBJECTS
      loop at ddic_types into attrib_type
                         where is_status_ref = gfw_true.
        assign component attrib_type-attribute of structure obj_copy
                                               to <lcl_dc_prest_attrib>.
        if sy-subrc <> 0.
          retval = cl_gfw=>e_dc_unknown_attrib. exit. "//CANCEL
        endif.
        status_ref = <lcl_dc_prest_attrib>.
        if not status_ref is initial.
          call method status_ref->copy importing copy = obj_ref.
          <lcl_dc_prest_attrib> ?= obj_ref.
        endif.
      endloop.
      if retval <> cl_gfw=>ok.
        gfw_write retval
         'LCL_DC_PREST->SET_OBJ_VALUES' 'W'.                 "#EC NOTEXT
        exit.
      endif.
      append obj_copy to data.
*   SET MODES TO 'INSERTED'
      clear objmodes.
      do attrib_count times.
        single_offset-offset = sy-index - 1.
        objmodes+single_offset-offset(1) = ins_mode.
      enddo.
      append objmodes to modes.
*   SET FLAG FOR DISTRIBUTION
      if new_mode <> if_dc_access=>co_mode_init.
        distributed = gfw_false.
      endif.
      exit. "//READY
    endif. "KEY_IDX IS INITIAL
* NOT KEY_IDX IS INITIAL
* TO DO: UPDATE EXISTING OBJECT OR INSERT BEFORE EXISTING OBJECT
    if key_value =
       obj-objid.
*   UPDATE
*   CHECK STATUS REFERENCES, COPY STATUS OBJECTS
      loop at ddic_types into attrib_type
                         where is_status_ref = gfw_true.
        assign component attrib_type-attribute of structure obj_copy
                                               to <lcl_dc_prest_attrib>.
        if sy-subrc <> 0.
          retval = cl_gfw=>e_dc_unknown_attrib. exit. "//CANCEL
        endif.
        status_ref = <lcl_dc_prest_attrib>.
        if not status_ref is initial.
          call method status_ref->copy importing copy = obj_ref.
          <lcl_dc_prest_attrib> ?= obj_ref.
        endif.
      endloop.

      if not filter_attribute is initial.
        assign component filter_attribute of structure obj_copy
                         to <lcl_dc_prest_attrib>.
        if sy-subrc <> 0.
          retval = cl_gfw=>e_dc_unknown_attrib. exit. "//CANCEL
        endif.
        assign component filter_attribute of structure single_data
                         to <lcl_dc_prest_attrib_old>.
        if sy-subrc <> 0.
          retval = cl_gfw=>e_dc_unknown_attrib. exit. "//CANCEL
        endif.

        if <lcl_dc_prest_attrib_old> <>
           <lcl_dc_prest_attrib> and
           new_mode <> if_dc_access=>co_mode_init.
*       SAVE CHANGES IN FILTER (PREPARE GET_CHANGES)
          read table changed_filter into changed_filter_wa
                                    with table key objkey =
  single_data-objid.
          if sy-subrc = 0 or sy-subrc = 2.
            if changed_filter_wa-new_filter <> <lcl_dc_prest_attrib>.
              changed_filter_wa-new_filter = <lcl_dc_prest_attrib>.
              modify table changed_filter from changed_filter_wa.
            endif.
          else.
            changed_filter_wa-objkey     =
  single_data-objid.
            changed_filter_wa-old_filter =
                    <lcl_dc_prest_attrib_old>.
            changed_filter_wa-new_filter =
                    <lcl_dc_prest_attrib>.
            insert changed_filter_wa into table changed_filter.
          endif.
        endif.
      endif.

      if retval <> cl_gfw=>ok.
        gfw_write retval
         'LCL_DC_PREST->SET_OBJ_VALUES' 'W'.                 "#EC NOTEXT
        exit.
      endif.

      modify data from obj_copy index key_idx.
      if sy-subrc <> 0.
        retval = cl_gfw=>e_dc_int_tab.
      endif.
*   SET MODES TO 'UPDATED'
      read table modes into objmodes index key_idx.
      if sy-subrc <> 0 and sy-subrc <> 2.
        retval = cl_gfw=>e_dc_mode.
        gfw_write retval
         'LCL_DC_PREST->SET_OBJ_VALUES' 'W'.                 "#EC NOTEXT
        exit.
      endif.
      do attrib_count times.
        single_offset-offset = sy-index - 1.
*     CHECK IF THIS ATTRIBUTE IS CHANGED
        assign component sy-index of structure single_data to
                                                  <lcl_dc_prest_key>.
        assign component sy-index of structure obj to
                                                  <lcl_dc_prest_attrib>.
        if <lcl_dc_prest_key> <>
           <lcl_dc_prest_attrib> and
           objmodes+single_offset-offset(1) <>
                    if_dc_access=>co_mode_inserted_by_app and
           objmodes+single_offset-offset(1) <>
                    if_dc_access=>co_mode_inserted_by_gp.
*      VALUE CHANGED
          objmodes+single_offset-offset(1) = new_mode.
        endif.
      enddo.
      modify modes from objmodes index key_idx.
    else.
*   INSERT
      if obj-objid
                   is initial.
        retval = cl_gfw=>e_dc_no_keyval.
        gfw_write retval
         'LCL_DC_PREST->SET_OBJ_VALUES' 'W'.                 "#EC NOTEXT
        exit. "//CANCEL.
      endif.
*   CHECK DOUBLE KEY
      read table data with table key
      objid =
      obj-objid
                        transporting no fields.
      if sy-subrc = 0 or sy-subrc = 2.
*     KEY ALREADY EXISTS
        retval = cl_gfw=>e_dc_dbl_key.
        gfw_write retval
         'LCL_DC_PREST->SET_OBJ_VALUES' 'W'.                 "#EC NOTEXT
        exit. "//CANCEL, RETURN WITH ERROR
      endif.
*   INSERT
*   CHECK STATUS REFERENCES, COPY STATUS OBJECTS
      loop at ddic_types into attrib_type
                         where is_status_ref = gfw_true.
        assign component attrib_type-attribute of structure obj_copy
                                               to <lcl_dc_prest_attrib>.
        if sy-subrc <> 0.
          retval = cl_gfw=>e_dc_unknown_attrib. exit. "//CANCEL
        endif.
        status_ref = <lcl_dc_prest_attrib>.
        if not status_ref is initial.
          call method status_ref->copy importing copy = obj_ref.
          <lcl_dc_prest_attrib> ?= obj_ref.
        endif.
      endloop.
      if retval <> cl_gfw=>ok.
        gfw_write retval
         'LCL_DC_PREST->SET_OBJ_VALUES' 'W'.                 "#EC NOTEXT
        exit.
      endif.
      insert obj_copy into data index key_idx.
      if sy-subrc <> 0.
        retval = cl_gfw=>e_dc_int_tab.
      endif.
*   SET MODES TO 'INSERTED'
      clear objmodes.
      do attrib_count times.
        single_offset-offset = sy-index - 1.
        objmodes+single_offset-offset(1) = ins_mode.
      enddo.
      insert objmodes into modes index key_idx.
      if sy-subrc <> 0.
        retval = cl_gfw=>e_dc_int_tab.
      endif.
    endif.

* SET FLAG FOR DISTRIBUTION
    if new_mode <> if_dc_access=>co_mode_init.
      distributed = gfw_false.
    endif.

* DATA CHANGED -> INIT PERFORMANCE BUFFERS
    call method reset_data_changed_flags.

    gfw_write retval
     'LCL_DC_PREST->SET_OBJ_VALUES' 'W'.                     "#EC NOTEXT
  endmethod. "//SET_OBJ_VALUES

******
* **** SET_OBJ_TAB
******
  method set_obj_tab.
    field-symbols: <lcl_dc_prest_attrib>     type any.

    data: local_retval    type symsgno value cl_gfw=>ok,
          obj_count       type i,
          single_data     type gfwdcprest,
          tabix           type sy-tabix,
          statusref_count type i,
          attrib_type     type ty_ddic_type,
          status_ref      type ref to if_gfw_status,
          obj_ref         type ref to object,
          changed         type gfw_boolean value gfw_false.

* COPY NEW DATA TABLE
    data = objtab.

* CORRECT STATUS OBJECT REFERENCES IN DATA TABLE
* (STATUS OBJECTS HAVE TO BE COPIED)
* 1. LOOK FOR STATUS REFERENCE IN EACH DATA RECORD
* 2. COPY ALL STATUS OBJECTS
* 3. MODIFY DATA RECORD IN DATA TABLE
    loop at data into single_data.
      tabix   = sy-tabix.
      changed = gfw_false.
*   HANDLE EACH STATUS OBJECT (MAY BE MORE THAN ONE)
      clear statusref_count.
      loop at ddic_types into attrib_type
                         where is_status_ref = gfw_true.
*     STATUSREF ATTRIBUTE FOUND
        add 1 to statusref_count.
*     COPY OBJECT VIA FIELD SYMBOL
        assign component attrib_type-attribute of structure single_data
                                               to <lcl_dc_prest_attrib>.
        if sy-subrc <> 0.
          retval = cl_gfw=>e_dc_unknown_attrib. exit. "//CANCEL
        endif.
        status_ref = <lcl_dc_prest_attrib>.
        if not status_ref is initial.
*       COPY NON-INITIAL STATUS REF OBJECT
          call method status_ref->copy importing copy = obj_ref.
          <lcl_dc_prest_attrib> ?= obj_ref.
          changed = gfw_true.
        endif.
      endloop.
      if statusref_count is initial.
*     READY, NO STATUSREF IN DDIC STRUCT
        exit.
      elseif changed = gfw_true.
*     THERE WAS A NON-INITIAL STATUSREF OBJECT IN THIS DATA RECORD
*     -> MODIFY DATA RECORD IN DATA TABLE
        modify data from single_data index tabix.
      endif.
    endloop.

* INITIALIZE MODES TABLE:
* FILL MODES TAB WITH INITIAL MODE MASK FOR EACH DATA RECORD
    clear modes.
    call method reset_modes.
    describe table data lines obj_count.
    do obj_count times.
      append modes_initial to modes.
    enddo.

    if graphic_proxy_count > 0.
*   DISTRIBUTE AT NEXT SYNC POINT
      distributed = gfw_false.

*   NOTIFY GRAPHIC PROXIES TO READ ALL DATA (NO UPDATE READ).
      force_notify_read = gfw_true.
    endif.

    if retval is requested.
      retval = local_retval.
    endif.
  endmethod.


* DC_PRES IS USED AS TEMPLATE, FOLLOWING METHOD IS IN INCLUDE THERE;
* ALL OTHER DCS ONLY HAVE ONE INCLUDE AND FOLLOWING METHOD IS INTEGRATED
* IN THIS INCLUDE
method fill_table_mode_index.
  data: single_offset type ty_offset.
  data: ddic_type type ty_ddic_type.
  clear single_offset.
*
  single_offset-offset    = 0.
  single_offset-attribute = 'OBJID'.
  insert single_offset into table mode_offset.
  ddic_type-attribute     = 'OBJID'.
  ddic_type-is_ref        = gfw_false.
  ddic_type-is_status_ref = gfw_false.
  insert ddic_type     into table ddic_types.
*
  single_offset-offset    = single_offset-offset + 1.
  single_offset-attribute = 'GRPID'.
  insert single_offset into table mode_offset.
  ddic_type-attribute     = 'GRPID'.
  ddic_type-is_ref        = gfw_false.
  ddic_type-is_status_ref = gfw_false.
  insert ddic_type     into table ddic_types.
*
  single_offset-offset    = single_offset-offset + 1.
  single_offset-attribute = 'T_GRPID'.
  insert single_offset into table mode_offset.
  ddic_type-attribute     = 'T_GRPID'.
  ddic_type-is_ref        = gfw_false.
  ddic_type-is_status_ref = gfw_false.
  insert ddic_type     into table ddic_types.
*
  single_offset-offset    = single_offset-offset + 1.
  single_offset-attribute = 'FILTER'.
  insert single_offset into table mode_offset.
  ddic_type-attribute     = 'FILTER'.
  ddic_type-is_ref        = gfw_false.
  ddic_type-is_status_ref = gfw_false.
  insert ddic_type     into table ddic_types.
*
  single_offset-offset    = single_offset-offset + 1.
  single_offset-attribute = 'X_VAL'.
  insert single_offset into table mode_offset.
  ddic_type-attribute     = 'X_VAL'.
  ddic_type-is_ref        = gfw_false.
  ddic_type-is_status_ref = gfw_false.
  insert ddic_type     into table ddic_types.
*
  single_offset-offset    = single_offset-offset + 1.
  single_offset-attribute = 'T_X_VAL'.
  insert single_offset into table mode_offset.
  ddic_type-attribute     = 'T_X_VAL'.
  ddic_type-is_ref        = gfw_false.
  ddic_type-is_status_ref = gfw_false.
  insert ddic_type     into table ddic_types.
*
  single_offset-offset    = single_offset-offset + 1.
  single_offset-attribute = 'Y_VAL'.
  insert single_offset into table mode_offset.
  ddic_type-attribute     = 'Y_VAL'.
  ddic_type-is_ref        = gfw_false.
  ddic_type-is_status_ref = gfw_false.
  insert ddic_type     into table ddic_types.
*
  single_offset-offset    = single_offset-offset + 1.
  single_offset-attribute = 'Z_VAL'.
  insert single_offset into table mode_offset.
  ddic_type-attribute     = 'Z_VAL'.
  ddic_type-is_ref        = gfw_false.
  ddic_type-is_status_ref = gfw_false.
  insert ddic_type     into table ddic_types.
*
  single_offset-offset    = single_offset-offset + 1.
  single_offset-attribute = 'TEXT'.
  insert single_offset into table mode_offset.
  ddic_type-attribute     = 'TEXT'.
  ddic_type-is_ref        = gfw_false.
  ddic_type-is_status_ref = gfw_false.
  insert ddic_type     into table ddic_types.
*
  single_offset-offset    = single_offset-offset + 1.
  single_offset-attribute = 'CU_STATUS'.
  insert single_offset into table mode_offset.
  ddic_type-attribute     = 'CU_STATUS'.
  ddic_type-is_ref        = gfw_false.
  ddic_type-is_status_ref = gfw_false.
  insert ddic_type     into table ddic_types.
*
  single_offset-offset    = single_offset-offset + 1.
  single_offset-attribute = 'CU_REFOBJ'.
  insert single_offset into table mode_offset.
  ddic_type-attribute     = 'CU_REFOBJ'.
  ddic_type-is_ref        = gfw_false.
  ddic_type-is_status_ref = gfw_false.
  insert ddic_type     into table ddic_types.
*
  single_offset-offset    = single_offset-offset + 1.
endmethod. "//fill_table_mode_index

******
* **** RESET_DATA_CHANGED_FLAGS
******
  method reset_data_changed_flags.

    if last_get_value-data_changed_after_get = gfw_false.
      last_get_value-data_changed_after_get   = gfw_true.
    endif.

    if last_get_changes-data_changed_after_get = gfw_false.
      last_get_changes-data_changed_after_get = gfw_true.
    endif.

  endmethod.

******
* **** RESET_MODES
******
  method reset_modes.
    data: new_mode type i,
          objmodes type ty_mode.

    new_mode = if_dc_access=>co_mode_init.

* MODE=DELETED => DELETE
    clear del_data.
    clear modes_key_deleted.

    call method reset_data_changed_flags.

* SET OTHER MODES TO INIT.
    loop at modes into objmodes.
      objmodes = modes_initial.
      modify modes from objmodes.
    endloop.

* RESET FILTER CHANGES
    clear changed_filter.

    if retval is requested.
      retval = cl_gfw=>ok.
    endif.
  endmethod. "//RESET_MODES

******
* **** GET_ATTRIB_MASK
******
  method get_attrib_mask.
    field-symbols: <attrib_mask> type ty_mode.
    data: attribute type rollname,
          single_offset type ty_offset.

* CREATE ATTRIBUTE MASK
    create data attrib_mask type ty_mode.
    assign attrib_mask->* to <attrib_mask>.

* FILL ATTRIBUTE MASK
    loop at attrib_list into attribute.
*   GET OFFSET OF MODE FOR THIS ATTRIBUTE
      read table mode_offset into single_offset
                 with table key attribute = attribute
                 transporting offset.
      if sy-subrc <> 0 and sy-subrc <> 2.
        gfw_write cl_gfw=>e_dc_unknown_attrib
            'LCL_DC_PREST->GET_ATTRIB_MASK'                  "#EC NOTEXT
            'W'.
        exit. "//CANCEL
      endif.
      if if_dc_access=>co_mode_init = 1.
        <attrib_mask>+single_offset-offset(1) = bitmask_init.
      endif.
    endloop.

  endmethod. "//GET_ATTRIB_MASK


* ******** IF_DC_ACCESS **********

  method if_dc_access~get_changes.
* ******** IF_DC_ACCESS~GET_CHANGES **********
    field-symbols: <lcl_dc_prest_attrib> type any,
                   <attrib_mask> type ty_mode.

    data: single_data            type
  gfwdcprest,
          objmodes               type ty_mode,
          tmpmodes               type ty_mode,
          found                  type gfw_boolean,
          found_additional       type gfw_boolean,
          key_idx                type sy-tabix,
          obj_idx                type i,
          single_offset          type ty_offset,
          gp_data                type ty_dc_gp_data,
                                 "//CHECK AUTHORISATION, FILTER
          filter                 type i,
          start_idx_del_data     type sy-tabix,
          start_idx_modes        type sy-tabix,
          attrib_type            type ty_ddic_type,
                                 "// HANDLING OF IF_GFW_STATUS
          status_ref             type ref to if_gfw_status,
          obj_ref                type ref to object,
          changed_filter_wa      type ty_changed_filter,
          obj_is_deleted_for_gp  type gfw_boolean,
          obj_is_inserted_for_gp type gfw_boolean,
          filter_changed         type gfw_boolean,
          old_filter_in_gp_list  type gfw_boolean,
          new_filter_in_gp_list  type gfw_boolean,
          gp_changed_all_attrib  type gfw_boolean,
          offset                 type sy-index,
          filter_is_of_interest  type gfw_boolean value gfw_false.

    retval = cl_gfw=>ok.
    found = gfw_false. found_additional = gfw_false. clear obj_idx.
    clear gp_data.
* CHECK ID
    if not id = master_id.
*   CHECK IF GP IS SUBSCRIBED AND GET FILTER FOR GP
      read table graphic_proxy_list into gp_data
                           with table key id = id
                           transporting list_of_interest
                                        attrib_mask
                                        list_of_filter.
      if sy-subrc <> 0 and sy-subrc <> 2.
        retval = cl_gfw=>e_dc_authorisation.
        gfw_write retval
         'LCL_DC_PREST->~GET_CHANGES' 'W'.                   "#EC NOTEXT
        exit.
      elseif gp_data-filter_changed = gfw_true. "//UPDATE READ
        retval = cl_gfw=>e_dc_authorisation.
        gfw_write retval
         'LCL_DC_PREST->~GET_CHANGES,F'                      "#EC NOTEXT
         'W'.                                               "#EC NOTEXT
        exit.
      endif.
    endif.
* CHECK ATTRIBUTE FOR GP (IF NEEDED)
    if not id = master_id and
       not gp_data-list_of_interest is initial.
    read table gp_data-list_of_interest with table key name = attribute
                                        transporting no fields.
      if sy-subrc <> 0 and sy-subrc <> 2.
        retval = cl_gfw=>e_dc_authorisation.
        gfw_write retval
         'LCL_DC_PREST->~GET_CHANGES' 'W'.                   "#EC NOTEXT
        exit.
      endif.
    endif.

* GET TYPE FOR THIS ATTRIBUTE
    read table ddic_types into attrib_type
               with table key attribute = attribute.
    if sy-subrc <> 0 and sy-subrc <> 2.
      retval = cl_gfw=>e_dc_unknown_attrib.
      gfw_write retval
         'LCL_DC_PREST->~GET_CHANGES' 'W'.                   "#EC NOTEXT
      exit. "//CANCEL
    endif.

* DUE TO PERFORMANCE: CHECK IF ID IS CURRENT ID,
*                     LAST VALUE_COUNTER IS CURRENT VALUE_COUNTER...
    if id            = last_get_changes-id                 and
       value_counter = last_get_changes-value_counter      and
       last_get_changes-data_changed_after_get = gfw_false.
      retval = last_get_changes-retval.
*   DIRECT ACCESS TO LAST READ OBJECT

*   GET VALUE
      assign component attribute of structure last_get_changes-data
                                 to <lcl_dc_prest_attrib>.
      if sy-subrc <> 0.
        retval = cl_gfw=>e_dc_unknown_attrib.
        gfw_write retval
         'LCL_DC_PREST->~GET_CHANGES' 'W'.                   "#EC NOTEXT
        exit. "//CANCEL
      endif.
      if attrib_type-is_status_ref = gfw_true.
        status_ref = <lcl_dc_prest_attrib>.
        if not status_ref is initial.
          call method status_ref->copy importing copy = obj_ref.
          field_value ?= obj_ref.
        else.
          clear field_value.
        endif.
      else.
        field_value = <lcl_dc_prest_attrib>.
      endif.
*   GET MODE
      if not last_get_changes-mode_key_deleted is initial.
        mode = last_get_changes-mode_key_deleted.

      elseif not last_get_changes-modes is initial.
*     TO GET MODE FIRST GET OFFSET OF MODE FOR THIS ATTRIBUTE
        read table mode_offset into single_offset
                   with table key attribute = attribute
                   transporting offset.
        if sy-subrc <> 0 and sy-subrc <> 2.
          retval = cl_gfw=>e_dc_unknown_attrib.
          gfw_write retval
           'LCL_DC_PREST->~GET_CHANGES' 'W'.                 "#EC NOTEXT
          exit. "//CANCEL
        endif.
*     RETURN MODE FOR GIVEN ATTRIBUTE
        mode = last_get_changes-modes+single_offset-offset(1).
      else.
*     SHOULD NOT OCCUR
*     (MAYBE THERE'S AN ERROR IN IMPLEMENTATION OF DEL_OBJECT)
        retval = cl_gfw=>e_dc_mode.
        gfw_write retval
          'LCL_DC_PREST->..GET_CHA..'                        "#EC NOTEXT
          'E'.
        exit.
      endif.
      exit. "//READY
    endif.

* DUE TO PERFORMANCE: CHECK IF LAST ID IS CURRENT ID,
*                     LAST VALUE_COUNTER+1 IS CURRENT VALUE_COUNTER
    last_get_changes-value_counter = last_get_changes-value_counter + 1.
    if id            = last_get_changes-id                 and
       value_counter = last_get_changes-value_counter      and
       last_get_changes-data_changed_after_get = gfw_false.
*   CHANGE START INDEX OF LOOPS
      start_idx_del_data = last_get_changes-start_idx_del_data.
      start_idx_modes    = last_get_changes-start_idx_modes.
      obj_idx = value_counter - 1.
    else.
      start_idx_del_data = 1.
      start_idx_modes    = 1.
      clear obj_idx.
    endif.

    clear last_get_changes.

* CHECK IF FILTER ATRIBUTE IS IN LIST OF INTEREST
    if not filter_attribute is initial and
         not id = master_id and
         not gp_data-list_of_interest is initial.
      read table gp_data-list_of_interest
                         with table key name = filter_attribute
                         transporting no fields.
      if sy-subrc = 0 or sy-subrc = 2.
        filter_is_of_interest = gfw_true.
      endif.
    endif.

* LOOK FOR DELETED OBJECTS
    loop at del_data into single_data from start_idx_del_data.
      key_idx = sy-tabix.
*   CHECK FILTER IF NEEDED
      if not filter_attribute is initial and
         not id = master_id and
         not gp_data-list_of_filter is initial.
*       THERE ARE SOME FILTER->CHECK
        assign component filter_attribute of structure single_data
                                          to <lcl_dc_prest_attrib>.
        if sy-subrc <> 0.
          retval = cl_gfw=>e_dc_unknown_attrib. exit. "//CANCEL
        endif.
        filter = <lcl_dc_prest_attrib>.
        read table gp_data-list_of_filter
                   from filter transporting no fields.
        if sy-subrc <> 0 and sy-subrc <> 2.
          continue.
        endif.
      endif. "// CHECK FILTER
      obj_idx = obj_idx + 1.
      if obj_idx < value_counter. continue. endif.
*   OBJECT FOUND
      if found = gfw_true.
        found_additional = gfw_true.
        retval = cl_gfw=>i_dc_set_of_val.
        last_get_changes-retval = retval.
        exit.
      endif.
      found = gfw_true.
*   GET VALUE
      assign component attribute of structure single_data
                                 to <lcl_dc_prest_attrib>.
      if sy-subrc <> 0.
        retval = cl_gfw=>e_dc_unknown_attrib. exit. "//CANCEL
      endif.
      if attrib_type-is_status_ref = gfw_true.
        status_ref = <lcl_dc_prest_attrib>.
        if not status_ref is initial.
          call method status_ref->copy importing copy = obj_ref.
          field_value ?= obj_ref.
        else.
          clear field_value.
        endif.
      else.
        field_value = <lcl_dc_prest_attrib>.
      endif.
      last_get_changes-data = single_data.
      last_get_changes-start_idx_del_data = key_idx + 1.
      last_get_changes-start_idx_modes = 1.
*   GET MODE
      read table modes_key_deleted index key_idx
                             into last_get_changes-mode_key_deleted.
      if sy-subrc <> 0 and sy-subrc <> 2.
        retval = cl_gfw=>e_dc_int_tab.
        gfw_write retval
          'LCL_DC_PREST->..GET_CHA..'                        "#EC NOTEXT
          'W'.
        exit.
      endif.
      mode = last_get_changes-mode_key_deleted.
    endloop. "// DELETED
    if found_additional = gfw_true or retval <> cl_gfw=>ok.
      exit. "//READY OR RETURN ERROR
    endif.

*  LOOK FOR CHANGES
    loop at modes into objmodes from start_idx_modes
                                where table_line <> modes_initial.
*   GET RECORD FROM DATA TABLE
      key_idx = sy-tabix.
      read table data into single_data index key_idx.
      if sy-subrc <> 0 and sy-subrc <> 2.
        retval = cl_gfw=>e_dc_mode.
        exit.
      endif.
      obj_is_inserted_for_gp = gfw_false.
      obj_is_deleted_for_gp = gfw_false.
*   CHECK FILTER IF NEEDED
      if not filter_attribute is initial and
         not id = master_id and
         not gp_data-list_of_filter is initial.
*       THERE ARE SOME FILTER->CHECK
        assign component filter_attribute of structure single_data
                                          to <lcl_dc_prest_attrib>.
        if sy-subrc <> 0.
          retval = cl_gfw=>e_dc_unknown_attrib. exit. "//CANCEL
        endif.
        filter = <lcl_dc_prest_attrib>.
*     DID VALUE OF FILTER ATTRIBUTE CHANGED?
        filter_changed = gfw_false.
        old_filter_in_gp_list = gfw_false.
        read table changed_filter into changed_filter_wa
                   with table key objkey =
  single_data-objid.
        if sy-subrc = 0 or sy-subrc = 2.
          filter_changed = gfw_true.
*       CHECK IF OLD FILTER IS OF INTEREST FOR GRAPHICS PROXY
          read table gp_data-list_of_filter
                 from changed_filter_wa-old_filter
                 transporting no fields.
          if sy-subrc = 0 or sy-subrc = 2.
            old_filter_in_gp_list = gfw_true.
          endif.
        endif.
*     IS NEW/CURRENT FILTER VALUE OF INTEREST FOR GRAPHICS PROXY?
        read table gp_data-list_of_filter
                   from filter transporting no fields.
        if sy-subrc = 0 or sy-subrc = 2.
          new_filter_in_gp_list = gfw_true.
        else.
          new_filter_in_gp_list = gfw_false.
        endif.

        if ( filter_changed = gfw_false and
             new_filter_in_gp_list = gfw_false ) or
           ( filter_changed = gfw_true and
             new_filter_in_gp_list = gfw_false and
             old_filter_in_gp_list = gfw_false ).
*       OBJECT IS NOT OF INTEREST
          continue.
        elseif filter_changed = gfw_true.
          if new_filter_in_gp_list = gfw_true and
             old_filter_in_gp_list = gfw_false.
            obj_is_inserted_for_gp = gfw_true.
          elseif new_filter_in_gp_list = gfw_false and
             old_filter_in_gp_list = gfw_true.
            obj_is_deleted_for_gp = gfw_true.
          endif.
        endif.
*     IF NOTHING ELSE CHANGED THAN FILTER AND FILTER ITSELF ISN'T
*     REQUESTED -> SKIP OBJECT (NO RELEVANT CHANGES)
        if filter_is_of_interest = gfw_false.
          tmpmodes = objmodes.
          tmpmodes+filter_mode_offset(1) = if_dc_access=>mode_init.
          if tmpmodes = modes_initial and
            obj_is_inserted_for_gp = gfw_false and
            obj_is_deleted_for_gp = gfw_false.
            continue.
          endif.
        endif.
      endif. "// CHECK FILTER
*   CHECK MODES FOR LIST OF INTEREST (ATTRIBUTES) OF GP
      if not gp_data-attrib_mask is initial.
        assign gp_data-attrib_mask->* to <attrib_mask>.
*     CHECK ATTRIB MASK:
*     IF ALL ATTRIBUTES (MARKED WITH 1 IN ATTRIB MASK) ARE
*       0 IN OBJMODES, THERE'RE NO
*       RELEVANT CHANGES FOR THIS GP IN THIS OBJECT
*       (ATTRIB_MASK IS BUILD WITH 1110 FOR INTERESTING ATTRIBUTES
*        SO MODE 'INIT 0001 IS THE ONLY ONE THAT MATCHES;
*        MODE 0000 DOES NOT EXIST)
        if obj_is_inserted_for_gp = gfw_false and
           obj_is_deleted_for_gp = gfw_false  and
          ( objmodes z <attrib_mask> ).
*       NO RELEVANT ATTRIBUTE CHANGED
          continue.
        endif.
      endif.
*   CHECK IF GP ALREADY KNOWS ABOUT CHANGES IN OBJECT
      if gp_cause_of_changes = id.
        gp_changed_all_attrib = gfw_true.
        do attrib_count times.
          offset = sy-index - 1.
          if <attrib_mask> is assigned.
            if <attrib_mask>+offset(1) <> bitmask_init.
*           NOT OF INTEREST FOR GP
              continue.
            endif.
          endif.
          if objmodes+offset(1) =
              if_dc_access=>co_mode_inserted_by_app or
             objmodes+offset(1) =
              if_dc_access=>co_mode_updated_by_app.
*          CHANGED BY APPLICATION (NOT GP)
            gp_changed_all_attrib = gfw_false.
          endif.
        enddo.
*      IF GP_CHANGED_ALL_ATTRIB = GFW_TRUE.
**       CHANGES WERE MADE BY GRAPHICS PROXY THAT IS ASKING FOR CHANGES
**       => DO NOT SEND THIS OBJECT TO GP (GP ALREADY KNOWS ABOUT)
*        CONTINUE.
*      ENDIF.
      endif.

*   CHECK VALUE_COUNTER
      obj_idx = obj_idx + 1.
      if obj_idx < value_counter. continue. endif.

*   OBJECT FOUND
      if found = gfw_true.
        found_additional = gfw_true.
        last_get_changes-retval = retval.
        exit.
      endif.
      found = gfw_true.
*   GET VALUE
      assign component attribute of structure single_data
                                 to <lcl_dc_prest_attrib>.
      if sy-subrc <> 0.
        retval = cl_gfw=>e_dc_unknown_attrib. exit. "//CANCEL
      endif.
      if attrib_type-is_status_ref = gfw_true.
        status_ref = <lcl_dc_prest_attrib>.
        if not status_ref is initial.
          call method status_ref->copy importing copy = obj_ref.
          field_value ?= obj_ref.
        else.
          clear field_value.
        endif.
      else.
        field_value = <lcl_dc_prest_attrib>.
      endif.
      last_get_changes-data = single_data.
      last_get_changes-start_idx_del_data = start_idx_del_data.
      last_get_changes-start_idx_modes    = key_idx + 1.
*   GET MODE
      if obj_is_inserted_for_gp = gfw_true.
        if objmodes+filter_mode_offset(1) =
           if_dc_access=>co_mode_updated_by_app.
          mode = if_dc_access=>co_mode_inserted_by_app.
          last_get_changes-modes = modes_inserted_app.
        else.
          mode = if_dc_access=>co_mode_inserted_by_gp.
          last_get_changes-modes = modes_inserted_gp.
        endif.
      elseif obj_is_deleted_for_gp = gfw_true.
        if objmodes+filter_mode_offset(1) =
           if_dc_access=>co_mode_updated_by_app.
          mode = if_dc_access=>co_mode_deleted_by_app.
          last_get_changes-modes = modes_deleted_app.
        else.
          mode = if_dc_access=>co_mode_deleted_by_gp.
          last_get_changes-modes = modes_deleted_gp.
        endif.
      else.
*     TO GET MODE FIRST GET OFFSET OF MODE FOR THIS ATTRIBUTE
        read table mode_offset into single_offset
                   with table key attribute = attribute
                   transporting offset.
        if sy-subrc <> 0 and sy-subrc <> 2.
          retval = cl_gfw=>e_dc_unknown_attrib. exit. "//CANCEL
        endif.
*     RETURN MODE FOR GIVEN ATTRIBUTE
        mode = objmodes+single_offset-offset(1).
        last_get_changes-modes = objmodes.
      endif.
    endloop. "//MODES
    if retval = cl_gfw=>ok.
      if found = gfw_false.
        retval = cl_gfw=>e_dc_not_found.
        clear value_counter.
      elseif found_additional = gfw_true.
        retval = cl_gfw=>i_dc_set_of_val.
      endif.
    endif.

* SAVE PARAMETER
    last_get_changes-id                     = id.
    last_get_changes-value_counter          = value_counter.
    last_get_changes-retval                 = retval.
    last_get_changes-data_changed_after_get = gfw_false.

  endmethod.

  method if_dc_access~set_value.
* ******** IF_DC_ACCESS~SET_VALUE **********
* IT'S NOT POSSIBLE TO CHECK FILTER AND RETURN ERROR IF FILTER DOESN'T
* MATCH A FILTER IN THE GP'S FILTER LIST IN THIS METHODE BECAUSE OF
* TEMPORARY INITIAL WHILE INSERTING AN OBJECT ATTRIBUTE AFTER ATTRIBUTE.
* 1ST INSERT OBJECT WITH KEY ATTRIBUTE
* NTH CHANGE OBJECT SET OTHER ATTRIBUTES
*----------------------------------------------------------------------*
    field-symbols: <lcl_dc_prest_attrib> type any.

    data: new_mode          type i,              "//KIND OF CHANGE
          ins_mode          type i,              "//KIND OF INSERT
          key_idx           type i,              "//TABIX OF KEY OBJECT
          gp_data           type ty_dc_gp_data, "//CHECK AUTHORISATION
          single_data       type
  gfwdcprest,
        single_offset     type ty_offset, "// OFFSET OF ATTR. (FOR MODE)
         objmodes          type ty_mode,   "// ALL MODES OF CURR. OBJECT
         attrib_type       type ty_ddic_type,   "// HANDLE IF_GFW_STATUS
          status_ref        type ref to if_gfw_status,
          obj_ref           type ref to object,
          changed_filter_wa type ty_changed_filter.

    retval = cl_gfw=>ok.

* TO SET MODE FIRST GET OFFSET OF MODE FOR THIS ATTRIBUTE
    read table mode_offset into single_offset
               with table key attribute = attribute
               transporting offset.
    if sy-subrc <> 0 and sy-subrc <> 2.
      retval = cl_gfw=>e_dc_unknown_attrib. exit. "//CANCEL
    endif.

* GET TYPE FOR THIS ATTRIBUTE
    read table ddic_types into attrib_type
               with table key attribute = attribute.
    if sy-subrc <> 0 and sy-subrc <> 2.
      retval = cl_gfw=>e_dc_unknown_attrib. exit. "//CANCEL
    endif.

* GET NEW MODE
    if id = master_id.
      if graphic_proxy_count > 0.
        new_mode = if_dc_access=>co_mode_updated_by_app.
        ins_mode = if_dc_access=>co_mode_inserted_by_app.
      else.
        new_mode = if_dc_access=>co_mode_init.
        ins_mode = if_dc_access=>co_mode_init.
      endif.
    elseif not gp_cause_of_changes is initial and
           gp_cause_of_changes <> id.
      retval = cl_gfw=>e_dc_two_gp_change.
      gfw_write retval
      'LCL_DC_PREST->SET_OBJ_VALUES'                         "#EC NOTEXT
      'W'.
      exit.
    else.
*   CHECK IF GP IS SUBSCRIBED
      read table graphic_proxy_list into gp_data
                           with table key id = id
                           transporting list_of_filter.
      if sy-subrc <> 0 and sy-subrc <> 2.
        retval = cl_gfw=>e_dc_authorisation.
        exit.
      endif.
      gp_cause_of_changes = id.
      new_mode = if_dc_access=>co_mode_updated_by_gp.
      ins_mode = if_dc_access=>co_mode_inserted_by_gp.
    endif.

    clear key_idx. clear single_data.
*   LOOK FOR OBJECT WITH GIVEN KEY (KEY OBJECT)
    if not key_value is initial.
      read table data with table key
      objid
                      = key_value
                      into single_data.
      if sy-subrc = 0 or sy-subrc = 2.
        key_idx = sy-tabix.
      endif.
    endif. "NOT KEY_VALUE IS INITIAL

    if key_idx is initial.
*   TO DO: APPEND NEW OBJECT
*   CHECK KEY
      if attribute <> key_attribute or field_value is initial.
*     KEY MISSING
        retval = cl_gfw=>e_dc_no_keyval.
        exit. "//CANCEL, RETURN WITH ERROR
      elseif attribute = key_attribute.
*     CHECK DOUBLE KEY
        read table data with table key
        objid
                        = field_value
                        transporting no fields.
        if sy-subrc = 0 or sy-subrc = 2.
*       KEY ALREADY EXISTS
          retval = cl_gfw=>e_dc_dbl_key.
          exit. "//CANCEL, RETURN WITH ERROR
        endif.
      endif.
*   KEY OK, APPEND OBJECT
      clear single_data.
      assign component attribute of structure single_data to
      <lcl_dc_prest_attrib>.
      if sy-subrc <> 0.
        retval = cl_gfw=>e_dc_unknown_attrib.
        exit. "//CANCEL
      endif.
      if attrib_type-is_status_ref = gfw_true.
        status_ref = field_value.
        if not status_ref is initial.
          call method status_ref->copy importing copy = obj_ref.
          <lcl_dc_prest_attrib> ?= obj_ref.
        endif.
      else.
        <lcl_dc_prest_attrib> = field_value.
      endif.
      append single_data to data.
*   SET MODE TO 'INSERTED'
      clear objmodes.
      do attrib_count times.
        single_offset-offset = sy-index - 1.
        objmodes+single_offset-offset(1) = ins_mode.
      enddo.
      append objmodes to modes.
*   SET FLAG FOR DISTRIBUTION
      if new_mode <> if_dc_access=>co_mode_init.
        distributed = gfw_false.
      endif.
      call method reset_data_changed_flags.
      exit. "//READY
    endif. "KEY_IDX IS INITIAL
* NOT KEY_IDX IS INITIAL
* TO DO: UPDATE EXISTING OBJECT OR INSERT BEFORE EXISTING OBJECT
    if attribute <> key_attribute.
*   UPDATE
      assign component attribute of structure single_data to
      <lcl_dc_prest_attrib>.
      if sy-subrc <> 0.
        retval = cl_gfw=>e_dc_unknown_attrib.
        exit. "//CANCEL
      endif.
      if attrib_type-is_status_ref = gfw_true.
        status_ref = field_value.
        if not status_ref is initial.
          call method status_ref->copy importing copy = obj_ref.
          <lcl_dc_prest_attrib> ?= obj_ref.
        endif.
      elseif attribute = filter_attribute and
             <lcl_dc_prest_attrib> <> field_value and
             new_mode <> if_dc_access=>co_mode_init.
*     SAVE CHANGES IN FILTER (PREPARE GET_CHANGES)
        read table changed_filter into changed_filter_wa
                                  with table key objkey =
  single_data-objid.
        if sy-subrc = 0 or sy-subrc = 2.
          if changed_filter_wa-new_filter <> field_value.
            changed_filter_wa-new_filter = field_value.
            modify table changed_filter from changed_filter_wa.
          endif.
        else.
          changed_filter_wa-objkey     =
  single_data-objid.
          changed_filter_wa-old_filter = <lcl_dc_prest_attrib>.
          changed_filter_wa-new_filter = field_value.
          insert changed_filter_wa into table changed_filter.
        endif.

        <lcl_dc_prest_attrib> = field_value.
      else.
        <lcl_dc_prest_attrib> = field_value.
      endif.
*   OPTIMIZATION: TRANSPORTING F1, BUT F1 IS HIDDEN IN ATTRIBUTE
      modify data from single_data index key_idx.
      if sy-subrc <> 0.
        retval = cl_gfw=>e_dc_int_tab.
      endif.
*   SET MODE TO 'UPDATED'
      read table modes into objmodes index key_idx.
      if sy-subrc <> 0 and sy-subrc <> 2.
        retval = cl_gfw=>e_dc_mode. exit.
      endif.
      if objmodes+single_offset-offset(1) <>
              if_dc_access=>co_mode_inserted_by_app and
         objmodes+single_offset-offset(1) <>
              if_dc_access=>co_mode_inserted_by_gp.
        objmodes+single_offset-offset(1) = new_mode.
        modify modes from objmodes index key_idx.
      endif.
*   SET FLAG FOR DISTRIBUTION
      if new_mode <> if_dc_access=>co_mode_init.
        distributed = gfw_false.
      endif.
      call method reset_data_changed_flags.
    else.
*   INSERT
      if field_value is initial.
        retval = cl_gfw=>e_dc_no_keyval.
        exit. "//CANCEL.
      endif.
*   CHECK DOUBLE KEY
      read table data with table key
      objid
                        = field_value
                        transporting no fields.
      if sy-subrc = 0 or sy-subrc = 2.
*     KEY ALREADY EXISTS
        retval = cl_gfw=>e_dc_dbl_key.
        exit. "//CANCEL, RETURN WITH ERROR
      endif.
*   INSERT
      clear single_data.
      assign component attribute of structure single_data to
      <lcl_dc_prest_attrib>.
      if sy-subrc <> 0.
        retval = cl_gfw=>e_dc_unknown_attrib.
        exit. "//CANCEL
      endif.
      if attrib_type-is_status_ref = gfw_true.
        status_ref = field_value.
        if not status_ref is initial.
          call method status_ref->copy importing copy = obj_ref.
          <lcl_dc_prest_attrib> ?= obj_ref.
        endif.
      else.
        <lcl_dc_prest_attrib> = field_value.
      endif.
      insert single_data into data index key_idx.
      if sy-subrc <> 0.
        retval = cl_gfw=>e_dc_int_tab.
      endif.
      call method reset_data_changed_flags.
*   SET MODE TO 'INSERTED'
      clear objmodes.
      do attrib_count times.
        single_offset-offset = sy-index - 1.
        objmodes+single_offset-offset(1) = ins_mode.
      enddo.
      insert objmodes into modes index key_idx.
      if sy-subrc <> 0.
        retval = cl_gfw=>e_dc_int_tab.
      endif.
*   SET FLAG FOR DISTRIBUTION
      if new_mode <> if_dc_access=>co_mode_init.
        distributed = gfw_false.
      endif.
    endif.
*
  endmethod.

  method if_dc_access~get_value.
* ******** IF_DC_ACCESS~GET_VALUE **********
    field-symbols: <lcl_dc_prest_attrib> type any,
                   <lcl_dc_prest_key>    type any.
    data: single_data       type
  gfwdcprest,
          obj_count         type i,
          found             type gfw_boolean,
          found_additional  type gfw_boolean, "//LOOK AHEAD
          single_offset     type ty_offset,
          objmodes          type ty_mode,
         gp_data           type ty_dc_gp_data, "//CHECK AUTHORIS, FILTER
          filter            type i,
          start_idx         type sy-tabix,
          current_key_value type char128,
          obj_idx           type i, "//TABLE INDEX OF FOUND OBJ
          attrib_type       type ty_ddic_type, "//HANDLING IF_GFW_STATUS
          status_ref        type ref to if_gfw_status,
          obj_ref           type ref to object,
          key_attrib        type rollname.

   retval = cl_gfw=>ok. found = gfw_false. found_additional = gfw_false.

* GET TYPE FOR THIS ATTRIBUTE
    read table ddic_types into attrib_type
               with table key attribute = attribute.
    if sy-subrc <> 0 and sy-subrc <> 2.
      retval = cl_gfw=>e_dc_unknown_attrib. exit. "//CANCEL
    endif.

* LOFFC 11TH OCT 1999: TOLERATE MISSING KEY_ATTRIBUTE
    if not key_value is initial and
       key_attribute is initial.
      key_attrib = me->key_attribute.
    else.
      key_attrib = key_attribute.
    endif.

* DUE TO PERFORMANCE: CHECK IF LAST KEY IS CURRENT KEY,
*                     LAST VALUE_COUNTER IS CURRENT VALUE_COUNTER...
    current_key_value = key_value.
    if id            = last_get_value-id                 and
       key_attrib    = last_get_value-key_attribute      and
       key_value     = last_get_value-key_value          and
       value_counter = last_get_value-value_counter      and
       last_get_value-data_changed_after_get = gfw_false.
      retval = last_get_value-retval.
*   GET VALUE
      assign component attribute of structure last_get_value-data
                                 to <lcl_dc_prest_attrib>.
      if sy-subrc <> 0.
        retval = cl_gfw=>e_dc_unknown_attrib.
        exit. "//CANCEL
      endif.
      if attrib_type-is_status_ref = gfw_true.
        status_ref = <lcl_dc_prest_attrib>.
        if not status_ref is initial.
          call method status_ref->copy importing copy = obj_ref.
          field_value ?= obj_ref.
        else.
          clear field_value.
        endif.
      else.
        field_value = <lcl_dc_prest_attrib>.
      endif.
*   TO GET MODE FIRST GET OFFSET OF MODE FOR THIS ATTRIBUTE
      read table mode_offset into single_offset
                 with table key attribute = attribute
                 transporting offset.
      if sy-subrc <> 0 and sy-subrc <> 2.
        retval = cl_gfw=>e_dc_unknown_attrib.
        exit. "//CANCEL
      endif.
*   RETURN MODE FOR GIVEN ATTRIBUTE
      mode = last_get_value-modes+single_offset-offset(1).
      exit. "//READY
    endif.

* DUE TO PERFORMANCE: CHECK IF LAST ID IS CURRENT ID,
*                     LAST VALUE_COUNTER+1 IS CURRENT VALUE_COUNTER
    last_get_value-value_counter = last_get_value-value_counter + 1.
    if id            = last_get_value-id                 and
       key_attrib    = last_get_value-key_attribute      and
       key_value     = last_get_value-key_value          and
       value_counter = last_get_value-value_counter      and
       last_get_value-data_changed_after_get = gfw_false.
*   CHANGE START INDEX OF LOOP
      start_idx = last_get_value-start_idx.
      obj_count = value_counter - 1.
    else.
      start_idx = 1.
      clear obj_count.
    endif.

* CHECK ID (GET LIST OF FILTER FOR GP)
    if not id = master_id.
*   CHECK IF GP IS SUBSCRIBED AND GET FILTER FOR GP
*   DUE TO PERFORMANCE: IGNORE LIST OF INTEREST
      read table graphic_proxy_list into gp_data
                           with table key id = id
                           transporting list_of_filter.
      if sy-subrc <> 0 and sy-subrc <> 2.
        retval = cl_gfw=>e_dc_authorisation.
        exit.
      endif.
    endif.

* IT'S NOT POSSIBLE TO LOOP WITH KEY BECAUSE OF DYNAMIC ATTRIBUTE NAMES,
* AS WELL IT'S NOT POSSIBLE TO USE TRANSPORTING DUE TO THE SAME REASON
    loop at data into single_data from start_idx.
      obj_idx = sy-tabix.
      if not key_attrib is initial.
        assign component key_attrib of structure single_data
                                       to <lcl_dc_prest_key>.
        if sy-subrc <> 0.
          retval = cl_gfw=>e_dc_unknown_attrib. exit. "//CANCEL
        endif.
        if not key_value = <lcl_dc_prest_key>.
          continue.
        endif.
      endif.
*   CHECK FILTER IF NEEDED
      if not filter_attribute is initial and
         not id = master_id and
         not gp_data-list_of_filter is initial.
*       THERE ARE SOME FILTER->CHECK
        assign component filter_attribute of structure single_data
                                          to <lcl_dc_prest_attrib>.
        if sy-subrc <> 0.
          retval = cl_gfw=>e_dc_unknown_attrib. exit. "//CANCEL
        endif.
        filter = <lcl_dc_prest_attrib>.
        read table gp_data-list_of_filter
                   from filter transporting no fields.
        if sy-subrc <> 0 and sy-subrc <> 2.
          continue.
        endif.
      endif. "// CHECK FILTER
      obj_count = obj_count + 1.
      if obj_count < value_counter. continue. endif.
*   OBJECT FOUND
      if found = gfw_true.
        found_additional      = gfw_true.
        retval                = cl_gfw=>i_dc_set_of_val.
        last_get_value-retval = retval.
        exit.
      endif.
      found = gfw_true.
*   GET VALUE
      assign component attribute of structure single_data
                                 to <lcl_dc_prest_attrib>.
      if sy-subrc <> 0.
        retval = cl_gfw=>e_dc_unknown_attrib. exit. "//CANCEL
      endif.
      if attrib_type-is_status_ref = gfw_true.
        status_ref = <lcl_dc_prest_attrib>.
        if not status_ref is initial.
          call method status_ref->copy importing copy = obj_ref.
          field_value ?= obj_ref.
        else.
          clear field_value.
        endif.
      else.
        field_value = <lcl_dc_prest_attrib>.
      endif.
      last_get_value-data      = single_data.
      last_get_value-start_idx = obj_idx + 1.
*   TO GET MODE FIRST GET OFFSET OF MODE FOR THIS ATTRIBUTE
      read table mode_offset into single_offset
                 with table key attribute = attribute
                 transporting offset.
      if sy-subrc <> 0 and sy-subrc <> 2.
        retval = cl_gfw=>e_dc_unknown_attrib. exit. "//CANCEL
      endif.
*   GET ALL MODES OF CURRENT OBJECT FROM MODES TABLE.
      read table modes into objmodes index obj_idx.
      if sy-subrc <> 0 and sy-subrc <> 2.
        retval = cl_gfw=>e_dc_mode. exit.
      endif.
*   RETURN MODE FOR GIVEN ATTRIBUTE
      mode = objmodes+single_offset-offset(1).
      last_get_value-modes = objmodes.
    endloop.
    if retval = cl_gfw=>ok.
      if found = gfw_false.
        retval = cl_gfw=>e_dc_not_found.
        clear value_counter.
      elseif found_additional = gfw_true.
        retval = cl_gfw=>i_dc_set_of_val.
      endif.
    endif.

* SAVE PARAMETER
    last_get_value-id                     = id.
    last_get_value-key_attribute          = key_attrib.
    last_get_value-key_value              = key_value.
    last_get_value-value_counter          = value_counter.
    last_get_value-retval                 = retval.
    last_get_value-data_changed_after_get = gfw_false.

  endmethod.

  method if_dc_access~del_object.
* ******** IF_DC_ACCESS~DEL_OBJECT **********
    field-symbols: <lcl_dc_prest_attrib> type any.
    data: key_idx           type i,
          gp_data           type ty_dc_gp_data,
          single_data       type
  gfwdcprest,
          empty_data        type
  gfwdcprest,
         objmodes          type ty_mode, "// ALL MODES OF CURRENT OBJECT
          del_mode          type x,
          filter            type i,
          changed_filter_wa type ty_changed_filter.

    retval = cl_gfw=>ok.
* CHECK ID
    if not id = master_id.
      if not gp_cause_of_changes is initial and
           gp_cause_of_changes <> id.
        retval = cl_gfw=>e_dc_two_gp_change.
        gfw_write retval
        'LCL_DC_PREST->SET_OBJ_VALUES'                       "#EC NOTEXT
        'W'.
        exit.
      endif.
*   CHECK IF GP IS SUBSCRIBED AND GET FILTER FOR GP
      read table graphic_proxy_list into gp_data
                           with table key id = id
                           transporting list_of_filter.
      if sy-subrc <> 0 and sy-subrc <> 2.
        retval = cl_gfw=>e_dc_authorisation.
        exit.
      endif.
      gp_cause_of_changes = id.
    endif.

*  GET OBJECT
    read table data with table key
    objid
                    = key_value
                    into single_data.
    if sy-subrc = 0 or sy-subrc = 2.
      key_idx = sy-tabix.
*   CHECK FILTER IF NEEDED
      if not filter_attribute is initial and
         not id = master_id and
         not gp_data-list_of_filter is initial.
*       THERE ARE SOME FILTER->CHECK
        assign component filter_attribute of structure single_data
                                          to <lcl_dc_prest_attrib>.
        if sy-subrc <> 0.
          retval = cl_gfw=>e_dc_unknown_attrib. exit. "//CANCEL
        endif.
        filter = <lcl_dc_prest_attrib>.
        read table gp_data-list_of_filter
                   from filter transporting no fields.
        if sy-subrc <> 0 and sy-subrc <> 2.
          retval = cl_gfw=>e_dc_authorisation.
        endif.
      endif. "// CHECK FILTER
    else.
      retval = cl_gfw=>e_dc_not_found.
    endif.
    if retval <> cl_gfw=>ok. exit. endif.
* CHECK IF OBJECT IS INSERTED SINCE LAST DISTRIBUTION
* (= MARKED AS INSERTED)
    read table modes into objmodes index key_idx.
    if sy-subrc <> 0 and sy-subrc <> 2.
      retval = cl_gfw=>e_dc_mode. exit.
    endif.
    if objmodes+key_mode_offset(1) <>
              if_dc_access=>co_mode_inserted_by_app and
       objmodes+key_mode_offset(1) <>
              if_dc_access=>co_mode_inserted_by_gp.
*   OBJECT IS NOT MARKED AS 'INSERTED'
*   => MOVE OBJECT TO TABLE WITH "DELETED" OBJECTS
*   LOOK FOR DOUBLE KEY (REINSERTED OBJECTS CAN BE DELETED DIRECTLY)
      read table del_data with table key
      objid
                          = key_value
                          transporting no fields.
      if sy-subrc <> 0 and sy-subrc <> 2.
*     OBJECT IS NOT YET MARKED TO BE "DELETED" -> MARK
        if not filter_attribute is initial.
*       RESET CHANGES IN FILTER (PREPARE GET_CHANGES)
          assign component filter_attribute of structure single_data
                                            to <lcl_dc_prest_attrib>.
          read table changed_filter into changed_filter_wa
                                   with table key objkey = key_value.
          if sy-subrc = 0 or sy-subrc = 2.
*         FILTER CHANGES SINCE LAST DISTRIBUTION -> RESET FILTER
            <lcl_dc_prest_attrib> = changed_filter_wa-old_filter.
          endif.
        endif.
*     OBJECTS ARE IDENTIFIED BY KEY => NO INSERT NECESSARY, APPEND IS OK
        append single_data to del_data.

*     SET MODE TO 'DELETED'
        if objmodes+key_mode_offset(1) =
                                    if_dc_access=>co_mode_updated_by_gp.
          del_mode = if_dc_access=>co_mode_deleted_by_gp.
        else.  "UPDATED_APP OR INIT
          del_mode = if_dc_access=>co_mode_deleted_by_app.
        endif.
*     INSERT MODE 'DELETED' FOR KEY (= MODE OF ALL ATTRIBUTES)
        append del_mode to modes_key_deleted.

*     DELETE USUAL MODE MARKS FOR THIS OBJECT
        delete modes index key_idx.
        if sy-subrc = 4. "//NOT FOUND
          retval = cl_gfw=>e_dc_mode.
        elseif sy-subrc <> 0.
          retval = cl_gfw=>e_dc_int_tab.
        endif.
      endif.
    endif.
* DELETE OBJECT FROM USUAL DATA TABLE
    delete data index key_idx.
    if sy-subrc <> 0. retval = cl_gfw=>e_dc_int_tab. exit. endif.

    call method reset_data_changed_flags.

    if graphic_proxy_count > 0.
      distributed = gfw_false.
    elseif distributed = gfw_true.
*   NO GRAPHIC PROXY SUBSCRIBED AND NO CHANGE MARKS
      clear del_data.
      clear modes_key_deleted.
    endif.
*
  endmethod.

  method if_dc_access~clear.
* ******** IF_DC_ACCESS~CLEAR **********
    data: single_data type
  gfwdcprest,
          offset      type sy-tabix.
    retval = cl_gfw=>ok.

    if not id = master_id.
*   CHECK IF GP IS SUBSCRIBED
      read table graphic_proxy_list
                           with table key id = id
                           transporting no fields.
      if sy-subrc <> 0 and sy-subrc <> 2.
        retval = cl_gfw=>e_dc_authorisation.
        exit.
      endif.
    endif.
    offset = 1.
    do.
      read table data into single_data index offset
        transporting objid.
      if sy-subrc <> 0.
        exit. "//READY
      endif.
      call method if_dc_access~del_object
                      exporting id = id
                                key_value =
  single_data-objid
                      importing retval = retval.
      if retval = cl_gfw=>e_dc_authorisation.
*     MAY BE GP IS NOT ALLOWED TO DELETE OBJECT (FILTER)
        add 1 to offset.
        continue.
      endif.
      if retval <> cl_gfw=>ok. exit. endif.
    enddo.

* DUE TO PERFORMANCE:
* ASSUME METHOD 'CLEAR' CAUSES A LOT OF CHANGES =>
* NOTIFY GRAPHIC PROXIES TO READ ALL DATA (NO UPDATE READ).
    force_notify_read = gfw_true.

  endmethod.

  method if_dc_access~get_predecessor.
* ******** IF_DC_ACCESS~GET_PREDECESSOR **********
    field-symbols: <lcl_dc_prest_attrib> type any.
    data: single_data       type
  gfwdcprest,
          last_key          type
gfwdcprest-objid
                                 ,
         gp_data           type ty_dc_gp_data, "//CHECK AUTHORIS, FILTER
          filter            type i.

    if not pred_key_value is requested.
      exit.
    endif.

* CHECK ID
    if not id = master_id.
*   CHECK IF GP IS SUBSCRIBED AND GET FILTER FOR GP
      read table graphic_proxy_list into gp_data
                           with table key id = id
                           transporting list_of_interest list_of_filter.
      if sy-subrc <> 0 and sy-subrc <> 2.
        gfw_write cl_gfw=>e_dc_authorisation
         'LCL_DC_PREST->GET_PRED..'                          "#EC NOTEXT
         'W'.
        exit.
      endif.
    endif.

    loop at data into single_data.

*   CHECK FILTER IF NEEDED
      if not filter_attribute is initial and
         not id = master_id and
         not gp_data-list_of_filter is initial.
*       THERE ARE SOME FILTER->CHECK
        assign component filter_attribute of structure single_data
                                          to <lcl_dc_prest_attrib>.
        if sy-subrc <> 0.
          gfw_write cl_gfw=>e_dc_unknown_attrib
          'LCL_DC_PREST->GET_PRED..'                         "#EC NOTEXT
          'W'.
          exit. "//CANCEL
        endif.
        filter = <lcl_dc_prest_attrib>.
        read table gp_data-list_of_filter
                   from filter transporting no fields.
        if sy-subrc <> 0 and sy-subrc <> 2.
          continue.
        endif.
      endif. "// CHECK FILTER

      if key_value =
         single_data-objid.
*     READY, OBJECT FOUND
        pred_key_value = last_key.
        exit.
      else.
        last_key = single_data-objid.
      endif.

    endloop.

  endmethod.

  method if_dc_access~get_successor.
* ******** IF_DC_ACCESS~GET_SUCCESSOR **********
    field-symbols: <lcl_dc_prest_attrib> type any.
    data: single_data       type
  gfwdcprest,
         gp_data           type ty_dc_gp_data, "//CHECK AUTHORIS, FILTER
          filter            type i,
          key_idx           type i.

    if not succ_key_value is requested.
      exit.
    endif.

    clear succ_key_value.

* CHECK ID
    if not id = master_id.
*   CHECK IF GP IS SUBSCRIBED AND GET FILTER FOR GP
      read table graphic_proxy_list into gp_data
                           with table key id = id
                           transporting list_of_interest list_of_filter.
      if sy-subrc <> 0 and sy-subrc <> 2.
        gfw_write cl_gfw=>e_dc_authorisation
         'LCL_DC_HIER->GET_SUCC..'                          "#EC NOTEXT
         'W'.
        exit.
      endif.
    endif.

* GET OBJECT
    read table data with table key
    objid
                    = key_value
                    into single_data.
    if sy-subrc <> 0 and sy-subrc <> 2.
      gfw_write cl_gfw=>e_dc_not_found
      'LCL_DC_HIER->GET_SUCC..'                             "#EC NOTEXT
      'W'.
      exit.
    endif.
    key_idx = sy-tabix.

* CHECK FILTER IF NEEDED
    if not filter_attribute is initial and
       not id = master_id and
       not gp_data-list_of_filter is initial.
*     THERE ARE SOME FILTER->CHECK
      assign component filter_attribute of structure single_data
                                        to <lcl_dc_prest_attrib>.
      if sy-subrc <> 0.
        gfw_write cl_gfw=>e_dc_unknown_attrib
        'LCL_DC_HIER->GET_SUCC..'                           "#EC NOTEXT
        'W'.
        exit.
      endif.
      filter = <lcl_dc_prest_attrib>.
      read table gp_data-list_of_filter
                 from filter transporting no fields.
      if sy-subrc <> 0 and sy-subrc <> 2.
        gfw_write cl_gfw=>e_dc_authorisation
       'LCL_DC_HIER->GET_SUCC..'                            "#EC NOTEXT
       'W'.
        exit.
      endif.
    endif. "// CHECK FILTER

    add 1 to key_idx.

    loop at data into single_data from key_idx.

*   CHECK FILTER IF NEEDED
      if not filter_attribute is initial and
         not id = master_id and
         not gp_data-list_of_filter is initial.
*       THERE ARE SOME FILTER->CHECK
        assign component filter_attribute of structure single_data
                                          to <lcl_dc_prest_attrib>.
        if sy-subrc <> 0.
          gfw_write cl_gfw=>e_dc_unknown_attrib
          'LCL_DC_HIER->GET_SUCC..'                         "#EC NOTEXT
          'W'.
          exit. "//CANCEL
        endif.
        filter = <lcl_dc_prest_attrib>.
        read table gp_data-list_of_filter
                   from filter transporting no fields.
        if sy-subrc <> 0 and sy-subrc <> 2.
          continue.
        endif.
      endif. "// CHECK FILTER

*   READY, OBJECT FOUND
      succ_key_value = single_data-objid.
      exit.

    endloop.

  endmethod.


endclass. "//LCL_DC_PREST IMPLEMENTATION
*

----------------------------------------------------------------------------------
Extracted by Mass Download version 1.4.6 - E.G.Mellodew. 1998-2024. Sap Release 754
